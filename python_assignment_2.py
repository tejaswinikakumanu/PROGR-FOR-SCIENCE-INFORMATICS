# -*- coding: utf-8 -*-
"""Python Assignment 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19Y5G-C94Plm6beNo4L828efwk9Pw-iC4
"""

# Q1: Read sequence from file and print specific letters

# Open the FASTA file and read lines
with open("chr1_GL383518v1_alt (1).fa") as file:
    lines = file.readlines()

# Remove FASTA header and join all sequence lines, converting to uppercase
sequence = "".join([line.strip() for line in lines if not line.startswith(">")]).upper()

# Print the 10th and 758th letters (1-based indexing)
print("Q1:")
print("10th letter:", sequence[9])       # Index 9 for 10th letter
print("758th letter:", sequence[757])    # Index 757 for 758th letter
print()

# Q2: Create reverse complement and print specific positions

# Base complement dictionary
complement = {
    "A": "T",
    "T": "A",
    "C": "G",
    "G": "C",
    "N": "N"  # Handle ambiguous base
}

# Generate reverse complement using the uppercase sequence
reverse_complement = "".join([complement.get(base, "N") for base in reversed(sequence)])

# Print the 79th letter (1-based, so index 78)
print("Q2:")
print("79th letter of reverse complement:", reverse_complement[78])

# Print bases from position 500 to 800 (1-based, so indexes 499:800)
print("500th to 800th letters of reverse complement:", reverse_complement[499:800])
print()

# Q3: Create nested dictionary counting nucleotides per kilobase (1000 bp)

from collections import defaultdict

# Initialize dictionary to hold counts per 1000-base segment
nuc_dict = {}

# Loop over sequence in 1000-base chunks
for i in range(0, len(sequence), 1000):
    start = i
    end = i + 1000
    chunk = sequence[start:end]

    # Count nucleotides in this chunk
    counts = defaultdict(int)
    for base in chunk:
        counts[base] += 1

    # Store counts dictionary keyed by the start position of the chunk
    nuc_dict[start] = dict(counts)

# Print counts for the first kilobase as an example
print("Q3:")
print("Counts for kilobase starting at 0:", nuc_dict[0])
print()

# Q4: Analyze nucleotide counts per kilobase

# Q4a: Counts in first 1000 bases
first_kb_counts = nuc_dict[0]
kb_list_a = [
    first_kb_counts.get("A", 0),
    first_kb_counts.get("C", 0),
    first_kb_counts.get("G", 0),
    first_kb_counts.get("T", 0)
]
print("Q4a:")
print("Nucleotide counts in first kilobase [A, C, G, T]:", kb_list_a)
print()

# Q4b: Counts for every kilobase
all_kb_lists = []
for kb_start in sorted(nuc_dict.keys()):
    counts = nuc_dict[kb_start]
    kb_list = [
        counts.get("A", 0),
        counts.get("C", 0),
        counts.get("G", 0),
        counts.get("T", 0),
    ]
    all_kb_lists.append(kb_list)

print("Q4b:")
print(f"Total kilobases counted: {len(all_kb_lists)}")
print("First kilobase counts:", all_kb_lists[0])
print()

# Q4c: List containing all individual lists
print("Q4c:")
print("Showing first 3 kilobase count lists:")
for i, kb_list in enumerate(all_kb_lists[:3]):
    print(f"Kilobase {i}: {kb_list}")
print()

# Q4d: Calculate sum of each list
kb_sums = [sum(kb_list) for kb_list in all_kb_lists]
print("Q4d:")
print("Sums of nucleotide counts per kilobase (first 5):", kb_sums[:5])
print()

# Q4e:

# What is the expected sum for each list?
#The expected sum for each list is 1000, because each list represents nucleotide counts in a 1000-base pair (1 kilobase) segment.

#Are there any lists whose sums are not equal to the expected value?
#Yes. Typically, the last kilobaseâ€™s sum is less than 1000.

#Provide a general explanation for the differences in your expected results and your observed results.
#The total length of the DNA sequence may not be an exact multiple of 1000 bases. This means the final kilobase segment is shorter than 1000 bases, so the nucleotide counts sum to less than 1000. All other full kilobase segments should sum exactly to 1000.